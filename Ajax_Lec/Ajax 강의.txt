Ajax 강의


생활코딩 / 동빈나 

## 0. Web3 - Ajax 개요

JavaScript가 도입되면서 문서에서 애플리케이션으로 발전하기 시작함.
구글에 a를 넣으면 a의 추천검색어들과 aj를 쓰면 aj의 추천검색어들이 뜨게끔 가능한 이유는
WebBrouser가 Ajax와 통신을 해서 추천 검색어를 가져온다. 
이와 같은 기능을 가능하게끔 해주는 것이 Ajax.
우리는 Ajax라는 낚시대를 이용하여 필요한것만 가져오는 정교한 작업을 해볼것이다.


## 1. Ajax 수업의 목적

하나의 웹페이지를 구성하기 위한 파일이 천개고, 100MB라고 한다면
페이지를 전환할때 모든 파일을 받는것과, 클릭해서 부분적으로 변경하는 Ajax는 사용자 입장에서
가장 좋은 방법이다. 
즉, 시간과 돈과 네트워크 자원을 절약할수있는 아주 좋은 방법이다.
Single-Page Appilcation이라고도 한다.
하나의 페이지로 여러 페이지를 구현할 수 있는.
Ajax는 서버와 통신을 해야되기때문에 직접 파일을 열면 안된다.
웹서버를 통해서 웹사이트를 구동해야만 동작하게 된다.


## 2. 동적으로 컨텐츠 변경하기

html을 클릭했을때 본문이 바뀌는 부분을 js가 타겟팅을 하기위해서
태그를 인위적으로 바꿀 필요가있다.
ex) <article>
우리가 하고싶은 것은,
a href html을 클릭했을때, 웹브라우저야, 이 artilce이라는 태그 안쪽에 내가 얘기하는 tag를 꽂아넣어. 라고 말하는것.

예시)

일단 html(1번)링크를 지워버린다. 
onClick (event)에서 document.querySelect()가 article 태그를 읽을 수 있도록 해줘야 한다. 

    <li><a onclick="document.querySelector('article').innerHTML = '<h2>HTML</h2>HTML is....';">HTML</a></li>
    <li><a onclick="document.querySelector('article').innerHTML = '<h2>CSS</h2>CSS is....';">CSS</a></li>

이런식으로 동적으로 바꿀 수가 있다.
그러면 <article> 태그 안에 정상적으로 출력되는 것을 볼수가 있다.
그런데 안타깝게도 여기에 있는 이 정보들은 Index.html이라는 파일 안에 있다.
이 정보가 바뀔때마다 이 파일을 열어야 된다.
우리가 뭘 하고싶은 것이냐 ?
Ajax라는 방법을 이용해서 여기에 index.html 파일안에 때려박아놨던 코드가
이 파일안에 있는 것이 아닌, 별도의 파일명 (HTML)이라는 파일이 있어서
javascript에 의해서 해당되는 부분을 HTML 파일에서 읽어오게 하고싶은것이다.
CSS도 HTML도 모두 이런식의 방식으로 읽어오게 하고싶은 것이다.

링크를 클릭했을 때, 웹브라우저가 우리 대신에 웹서버에 접속해서 CSS, HTML의 내용만을 가져온다.


## 3. 5.0.fetch API 사용법

Ajax를 구현하는 최신방법중에fetch API 방법이 있다.
Fetch API를 테스트해보기 위해서 fetch.html이라는 파일을 만들었다.
버튼을 클릭했을때 fetch API가 동작하게 하고싶다.

<!DOCTYPE html>
<Html>
    <body>
        <input type="button" value="fetch" onclick="alert('hi')">
    </body>
</Html>

이렇게 구성

우리가 이 시점에서 과감한 실험을 하나 해볼것이다. 
무엇이냐면, 우리가 ajax를 사용하기 위해서 필요한 코드를 기계적으로 타이핑하도록
먼저 할것이다.

<!DOCTYPE html>
<Html>
    <body>
        <input type="button" value="fetch" 
        onclick="fetch('css').tehn(function(response){
            response.text().then(function(text){
                alert(text);
            })
        })
        ">
    </body>
</Html>

이렇게.

우리가 스마트폰을 쓸때 원리를 생각하면서 쓰지는 않는다.
여기 있는 이 코드도 마찬가지이다.
이 코드에서 우리가 관심을 가질만한 부분과 그렇지 않은 부분을 구분할것이다.
fetch버튼을 클릭하면 css파일의 내용이 경고창 (alert)으로 출력되는 것을 확인할수있다.
html도 마찬가지.
모든작업이 끝난 다음에는 alert(text)부분이 호출되도록 약속되어있고,
(text)라는 변수 안에 서버가 응답한 데이터가 들어가있다.

즉, html이라는 파일을 요청하고 응답이 끝나면, alert가 실행되면서 text라는 변수에 담겨있다는 것이다.
경고창 말고, webpage의 내용을 갖고오고 싶다면, article을 써서,

   <body>
        <article>


        </article>
        <input type="button" value="fetch" 
        onclick="fetch('html').then(function(response){
            response.text().then(function(text){
            document.querySelector('article').innerHTML = text;
            })
        })
        ">
   </body>
이렇게 수정해준다면 이번에는 alert창이 아닌 text로 보여준다.
이후에는 원리를 조금 볼것이다. 나온지 얼마 안된 기술이라, 강사님도 잘 모르신단다.

## 4. API - 요청과 응답

문법적인 부분을 조금 해석을 해볼것이다.

client와 server가 있으면 client가 우선 요청을하는데,
fetch(javascript)를 실행시키면 이건 무슨 뜻이냐,
client가 '웹브라우저야, js라는 파일을 server에 응답해줘' 라고 요청한것이다.
그럼 server가 응답을 할것이다.

그럼, 실습에서,

fetch('html'); 라고만 써두면 
클릭해보면, html에 접속해서 데이터를 가져오는 것을 볼수있다.
fetch라는 함수는 첫번째 인자를 서버로부터 요청하는 파일이다.


fetch('html').then(function(response){
            response.text().then(function(text){
            document.querySelector('article').innerHTML = text;
            })
        })

여기서, 
첫번째 .then은 
.then(function(response){
            response.text().then(function(text){
            document.querySelector('article').innerHTML = text;
            })
        })
여기까지가 하나이다.
.then이라는 녀석은
server가 적당한 데이터를 꺼내서 응답을 해줘야되는데,
응답을 해줄때 시간이 걸릴수도으니
1시간이 걸린다치면, server가 응답할때까지 다른 업무를 하게끔 하는 명령어이다.


function callbackme(){
	console.log('response end');
}
fetch('html').then(callbackme);

fetch API야 응답이 끝나면 내가 지금부터 정의하는 함수(callbackme())라는 함수를 실행시켜줘. 라고 말을 하는것이다.

위에  console.log를 또 추가시켜서 확인해보자.

       function callbackme(){
	    console.log('response end');
        }
        fetch('html').then(callbackme);
        console.log(1);
        console.log(2);

이렇게 여기서 보게되면, 
1,2가 실행이 되고, 웹브라우저가 응답받는게 끝나면 callbackme라는 함수를 호출해서 출력된다.
fetch api가 어떤 방식으로 출력되냐면,
"Asynchronous"
한국어로는 무슨 의미냐면, "비동기" 방식임.
"Synchronous"는 "동기"

동기로 실행됐다하면, 요청이 시작되고 끝날때까지 실행되지않고 저것들이 멈춰있어야 된다.
비동기는 fetch가 실행되는 동안에 다른 코드들이 실행되는것이다.
Ajax의 첫번째글자인 Asynchronous의 약자이다.

## 5. API-response 객체

우리가 이전에 썼던 코드는 then 안에 function이 들어가는 괴상한 모양을 하고있다.
이것을 익명함수라고 한다. 이름이 없는 함수.
함수가 이름이 필요한 경우는 여기저기서 부를떄 필요하다.
하지만 여기서는 then안에서만 독점적으로 사용하기때문에 이름을 가질 필요가없다.
그냥 한몸이 되면 된다.
그래서, 이런 경우는 똑같은 코드.

    function callbackme(){
	    console.log('response end');
        }
        callbackme = function(){
            console.log('response end');
        }
위에 것을 지워버리고 
  callbackme = function(){
            console.log('response end');
        }

그렇다면
   fetch('html').then(callbackme);
        console.log(1);
        console.log(2);
이 부분에서 then(callbackme)를 
callbackme대신 
function(){
            console.log('response end');
        }
이 녀석을 넣어도 되지않느냐. 맞다.
 fetch('html').then(function(){
            console.log('response end');
        }

그렇게 해서 익명함수를 사용할수있다.

fetch-API 사용 설명서를 보면 쉽지않다.
사용 설명서를 잘보면
then에 callback함수를 주게 되면 callback함수를 fetchAPI가 실행 시킬때,
저 함수의 첫번째 인자의 값으로 response의 값을 주겠습니다. 라고 되어있다.
이름은 아무렇게나 적어도 된다. 중요한것은 
fetch('html').then(function(아무이름)){
console.log('response end');
});
이 함수가 호출될떄 입력값을 주면서 호출할것이다. 라고 사용 설명서에 적혀있다.
우리가 구현한 fetch 버튼을 누르면 웹에서 개발도구창의 콘솔을 보면

Response {type: 'basic', url: 'http://127.0.0.1:5500/html', redirected: false, status: 200, ok: true, …}

이런것이 나오는데 status를 보면 200이 나온다.
웹브라우저와 웹서버가 통신을 할때 웹서버가 응답을 하면서 파일을 잘 정삭적으로 찾았다 !
그러면 200이라고 알려준다.
근데 요청한 파일이 존재하지 않는다면, 404를 던져준다(Not Found). 
Response라는 객체에 status라는 속성의 값이 200인 것이다.
그럼 만약 존재하지않는 파일을 fetch에 요청하면 어떤것이 뜰까 ? 

   fetch('Nothing').then(function(response){
        console.log(response);
        }); 

이 녀석을 요청해보면 

Response {type: 'basic', url: 'http://127.0.0.1:5500/Nothing', redirected: false, status: 404, ok: false, …}

status가 404가 뜨는 것을 볼수있다. 
404는 파일이없다는 전세계적인 약속이다.
웹서버가 404라는 녀석을 브라우저에 보내준다.
status라는 값을 어떻게 갖고오냐 ?
객체라는 것에서 .status를 쓰면 가져올수있다.

 fetch('html').then(function(response){
        console.log(response.status);
        })

이렇게.
이제 우리는 이것으로 
기능 구현을 하나 할수있게 되었다.
if(response.status == '404'){
alert('Not Found')
}


 fetch('Nothing').then(function(response){
      if(response.status == '404'){
alert('Not Found !')
}
});
alert창이 잘 뜬다.
response라는 객체는 fatch를 통해서 요청을 했을때 웹서버가 응답한 결과를 담고있는
객체, 데이터가 response라는 것이고 그 안에는 여러가지 속성을 통해서
우리가 어떤 상태로 통신이 이루어져있는지 알수있는 귀중한 것이 들어있다.
이렇게 우리가 원리를 알면 자유도가 높아진다.

## 6. Ajax의 적용

뭔가를 배웠으면 빨리 써먹어 봐야한다 !
우리가 쓴 저 코드들을 어떻게 써보면 될까 ?
우리가 활용하려는 index.html을 열어보자.
Onclick 부분을 fetch API를 가져와서 붙여넣을 것이다.


<ol>
    <li><a onclick="
    fetch('html').then(function(response){
      response.text().then(function(text){
       document.querySelector('article').innerHTML = text;
      })
  })">HTML</a></li>
    <li><a onclick="
    fetch('css').then(function(response){
      response.text().then(function(text){
       document.querySelector('article').innerHTML = text;
      })
  })">CSS</a></li>
    <li><a onclick="
      fetch('javascript').then(function(response){
        response.text().then(function(text){
         document.querySelector('article').innerHTML = text;
        })
    })">JavaScript</a></li>
  </ol>
  <article>

  </article>

이렇게 이제 각각 수정을 했다.
이렇게 되면 사실 이제, 본질적인 다 한것이다.
우리의 예제에서는 아주 우아한 방법은 아니지만, Ajax가 무엇이다. 라는 것을
충분히 경험한 것이다.
Ajax를 배우는것도 목표이지만, web App이 어떻게 개발해나가는 것인지도 같이 배워나갈 것이다.
싱글 페이지를 만드는 과정도 같이 해볼것이다 !

##7. 리팩토링 함수화

자 이제우리는 Ajax의 본질을 빠르게 살펴봤으니, 조금 더 우아하게 개선, 발전시켜 나가보자.
저 위에 코드를 보면, 중복이 발생하고있다.
우리가 코딩을 하는 과정에서 우리가 언제나 고심해야 될 부분이, 어떻게 해야 중복을 제거할것인가 이다.
위에 코드를 보면 중복이 있는 부분이 있고, 중복이 되면 안되는 부분이있다.
이걸 어떻게 해야될까 ?

함수를 이용하면 된다.
script를 열고

fetch('html').then(function(response){
      response.text().then(function(text){
       document.querySelector('article').innerHTML = text;
      })
  })

이 코드를 재활용하는 것이 목표이다.
재활용을 하기 위해 우리는, 코드 친구들을 함수로 묶을 것이다.

  <script>
  function fetchPage(){
    fetch('html').then(function(response){
      response.text().then(function(text){
       document.querySelector('article').innerHTML = text;
      })
  })
}
  </script>


이 코드에서 바뀔수있는 부분은 fetch() 하나이다.
그럼 fetchPage(name) 이라고 하고
name으로 들어오는 매개변수를 fetch에 인자로 넣어주면 된다.
그럼 fetch라는 녀석을 이렇게 정의했으면
조금더 아름답게 만들수있다.

  <li><a onclick="fetchPage('html')">HTML</a></li>

이런식으로 ! 얼마나 아름답고 감동적인가.... 가독성, 유지보수성 모두 챙겨간다...


## 8-1. 초기 페이지 (1/2)

이제부터는 Ajax 기능을 구현했을때 직면할수있는 부작용들을 완화해 나가는 방법을 살펴볼것이다.

우리가 구현한 것을 보면
첫번째로, 링크인데 밑줄이나 그런것이 없다.
두번째로, 우리가 알고있는 웹페이지는 하나씩 네비게이션처럼 정보를 보는 것 뿐만 아니라,
주소가 페이지별로 달라지는 것을 통해서 그 주소를 공유할수있는 측면도 있다.
그런 점에서 우리가 구현한 이것은 여러가지로 한계가 있는 상태이다.

우리는 hash라는 방법을 이용할것인데, hash가 뭔지 알 필요가있다.
우리가 page에 접근할때 url을 통해서 접근할수있다.
그런데, page안에서 어느 특정한 부분으로 접근하고 싶을때.

일단 hash.html 파일을 추가해줬다.
(참고: lorem글자수
이라는 명령어를 쓰면 랜덤한 글자를 생성해준다.)

<html>
    <body>
        <p>
        lolololo
        </p>
        <p>
        lolololo
        </p>
        <p>
        lolololo
        </p>
    </body>
</html>

이 컨텐츠에서 이렇게 문단이 여러개일때,
3번째 문단에 사용자에게 접근할수있도록 하고싶다면 ? URL을 통해서 ?
그때 사용하는 기능 ? 은 hash기능이라고 한다.
아무튼, BookMark를 할수있게 하는것이다.
그것을 하기 위해서는 식별하고싶은 곳에 id값을 주면 된다.
  <p id="three">
        lolololo
 </p>

근데 문단의 내용이 짧아서 내 눈으로 확인을 할수가 없기에, 
문단의 내용을 lorem을 이용하여 좀 늘려주었다. 
그랬더니 자동생성된 글자가 한줄로 주욱 나와서 
컨트롤 + , (설정창) 을 눌러서 word rap 검색, off로 되어있던 word rap을 켜주고 다시 문단의
내용을 lorem을 이용하여 글들을 자동 생성 시켜주었다.


이렇게 주고 url에 
http://127.0.0.1:5500/hash.html#three


를 주면 id값이 three인 곳으로 페이지 내에서 스크롤이 이동해버린다.
그렇게 되면 어떻게 될까 ? 이 주소를 다른 사람에게 공유하면 id값이 three인 
부분으로 바로 올수있다.
참고로 p태그는 조각이라는 뜻이다.
자 이제 여기서, 앵커를 한번 넣어보면, 
<a href="#three">three</a>
바로 세번째 문단으로 넘어간다.

이러한 특성을 이용해서 url에 색깔을 입힐수있다.
hash값이 무엇이냐에 따라서 Ajax로 다른 페이지를 로드해서 
시작되는 페이지를 셋팅할 수 있다.
그걸 어떻게 할수있냐 ?

hash.html에서
script를 열어주고,
현재 이 주소상에서 #에 해당되는 뒤에있는 값이 이 페이지의 무엇이냐 ? 를 알아야 된다.
검색을 통해서 how to get hash from url javascript 정도로 검색을 해보면
알아내는 방법들이 나온다.

      if(location.hash){

            }else{
                
            }

location.hash를 하면 이것이 #three의 값을 가르킨다. 
라는 것을 구글(...)의 누군가가 알려준것이다.
 console.log(location.hash);
이녀석을 통해 hash를 알아낼수있고, 현재 페이지의 hash가 있는가 없는가에 따라
hash라는 녀석을 출력하는 것이고, #부분을 보기싫으면, 없애려면,
검색을 해보자...
javascript how to get sub string 
(강사님께서 서브스트링을 이용했다.)

        	<script>
            if(location.hash){
                console.log(location.hash.substr(1));
            }else{

            }
        </script>

자 이렇게 보면 이제, three라는 녀석이 #이 없이 콘솔에 잘 나오고, url도 잘 이동되고있다.

## 8-2. 초기 페이지 (2/2)

<li><a onclick="fetchPage('html')">HTML</a></li>
여기에다가 hash를 적는것이다.

 <li><a href="#!html" onclick="fetchPage('html')">HTML</a></li>
이렇게 바꿔준다.
#이라는 녀석은 기본적으로 북마크 기능이기때문에
용도를 구분하기 위해 관습적으로 #!을 붙여준다.
#을 Hash라고 하고, !를 Bang이라고 해서 이것을
HashBang이라고도 부른다.

이제, 저렇게 각각 바꿔주면
링크가 생기고, 클릭하는 것에 따라 로드가 된다. url도 바뀜.
이 주소를 카피해서 누군가에게 공유했을떄, 그 사람이 저것을 클릭해서 들어왔을떄,
똑같은 페이지를 보려면, 

hash가있다면, fatchPage를 통해서 hash값을 주는데,
그 hash값은 substr으로 주면 된다(#!).
hash가 없다면 fetchPage를 통해 welcome이라는 것을 읽도록하고
default로 welcome이라는 것을 만들어주자.

if(location.hash){
	fetchPage(location.hash.substr(2)); -> 내가 보고있는 페이지 
}else{
	fetchPage('welcome');
}

잘 동작하는데
이 방식은 여러가지 맹점이있다.
Ajax를 이용해서 하게 되면 검색엔진 최적화가 잘 되지않는다.
검색엔진은 웹페이지를 다운로드 받아서 분석해야되는데,
이 웹페이지 자체는 실제 내용이 없다.
내용은 back end에서 동적으로 가져오니까.
그리고 네비게이션을 봤을떄 내용이 바뀌어야되는데 바뀌지 않는다.
그러나, 현시점에서는 해쉬뱅을 이용한 방식은 현시점에서 쓰지않고
현재는 "pjax"라고 하는 기술을 많이 사용한다.
이것은 새로운 기술이 아니라, 여러가지 방식을 보안한 기술이다.
필요할때 공부하면 된다.
